// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pb.proto

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		pb.proto

	It has these top-level messages:
		Camera
		Handshake
		HandshakeRsp
		InitUploadReq
		InitUploadRsp
		UploadReq
		UploadRsp
		UploadCompleteReq
		UploadCompleteRsp
		UploadContinue
*/
package pb

import (
	"fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	_ "github.com/gogo/protobuf/gogoproto"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Code int32

const (
	CodeSucc            Code = 0
	CodeBusy            Code = 1
	CodeMissing         Code = 2
	CodeInvalidChunk    Code = 3
	CodeInvalidChecksum Code = 4
	CodeOSSError        Code = 5
	CodeMaxRetries      Code = 6
)

var Code_name = map[int32]string{
	0: "CodeSucc",
	1: "CodeBusy",
	2: "CodeMissing",
	3: "CodeInvalidChunk",
	4: "CodeInvalidChecksum",
	5: "CodeOSSError",
	6: "CodeMaxRetries",
}
var Code_value = map[string]int32{
	"CodeSucc":            0,
	"CodeBusy":            1,
	"CodeMissing":         2,
	"CodeInvalidChunk":    3,
	"CodeInvalidChecksum": 4,
	"CodeOSSError":        5,
	"CodeMaxRetries":      6,
}

func (x Code) Enum() *Code {
	p := new(Code)
	*p = x
	return p
}
func (x Code) String() string {
	return proto.EnumName(Code_name, int32(x))
}
func (x *Code) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Code_value, data, "Code")
	if err != nil {
		return err
	}
	*x = Code(value)
	return nil
}
func (Code) EnumDescriptor() ([]byte, []int) { return fileDescriptorPb, []int{0} }

type Cmd int32

const (
	CmdHB                Cmd = 0
	CmdHandshake         Cmd = 1
	CmdHandshakeRsp      Cmd = 2
	CmdUploadInit        Cmd = 3
	CmdUploadInitRsp     Cmd = 4
	CmdUpload            Cmd = 5
	CmdUploadRsp         Cmd = 6
	CmdUploadComplete    Cmd = 7
	CmdUploadCompleteRsp Cmd = 8
	CmdUploadContinue    Cmd = 9
)

var Cmd_name = map[int32]string{
	0: "CmdHB",
	1: "CmdHandshake",
	2: "CmdHandshakeRsp",
	3: "CmdUploadInit",
	4: "CmdUploadInitRsp",
	5: "CmdUpload",
	6: "CmdUploadRsp",
	7: "CmdUploadComplete",
	8: "CmdUploadCompleteRsp",
	9: "CmdUploadContinue",
}
var Cmd_value = map[string]int32{
	"CmdHB":                0,
	"CmdHandshake":         1,
	"CmdHandshakeRsp":      2,
	"CmdUploadInit":        3,
	"CmdUploadInitRsp":     4,
	"CmdUpload":            5,
	"CmdUploadRsp":         6,
	"CmdUploadComplete":    7,
	"CmdUploadCompleteRsp": 8,
	"CmdUploadContinue":    9,
}

func (x Cmd) Enum() *Cmd {
	p := new(Cmd)
	*p = x
	return p
}
func (x Cmd) String() string {
	return proto.EnumName(Cmd_name, int32(x))
}
func (x *Cmd) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Cmd_value, data, "Cmd")
	if err != nil {
		return err
	}
	*x = Cmd(value)
	return nil
}
func (Cmd) EnumDescriptor() ([]byte, []int) { return fileDescriptorPb, []int{1} }

type Camera struct {
	Name             string `protobuf:"bytes,1,opt,name=Name" json:"Name"`
	Username         string `protobuf:"bytes,2,opt,name=Username" json:"Username"`
	Password         string `protobuf:"bytes,3,opt,name=Password" json:"Password"`
	Position         uint32 `protobuf:"varint,4,opt,name=Position" json:"Position"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Camera) Reset()                    { *m = Camera{} }
func (m *Camera) String() string            { return proto.CompactTextString(m) }
func (*Camera) ProtoMessage()               {}
func (*Camera) Descriptor() ([]byte, []int) { return fileDescriptorPb, []int{0} }

func (m *Camera) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Camera) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Camera) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Camera) GetPosition() uint32 {
	if m != nil {
		return m.Position
	}
	return 0
}

type Handshake struct {
	Mac              string `protobuf:"bytes,1,opt,name=mac" json:"mac"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Handshake) Reset()                    { *m = Handshake{} }
func (m *Handshake) String() string            { return proto.CompactTextString(m) }
func (*Handshake) ProtoMessage()               {}
func (*Handshake) Descriptor() ([]byte, []int) { return fileDescriptorPb, []int{1} }

func (m *Handshake) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

type HandshakeRsp struct {
	Shop             uint64    `protobuf:"varint,1,opt,name=shop" json:"shop"`
	Mac              string    `protobuf:"bytes,2,opt,name=mac" json:"mac"`
	Cameras          []*Camera `protobuf:"bytes,3,rep,name=cameras" json:"cameras,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *HandshakeRsp) Reset()                    { *m = HandshakeRsp{} }
func (m *HandshakeRsp) String() string            { return proto.CompactTextString(m) }
func (*HandshakeRsp) ProtoMessage()               {}
func (*HandshakeRsp) Descriptor() ([]byte, []int) { return fileDescriptorPb, []int{2} }

func (m *HandshakeRsp) GetShop() uint64 {
	if m != nil {
		return m.Shop
	}
	return 0
}

func (m *HandshakeRsp) GetMac() string {
	if m != nil {
		return m.Mac
	}
	return ""
}

func (m *HandshakeRsp) GetCameras() []*Camera {
	if m != nil {
		return m.Cameras
	}
	return nil
}

type InitUploadReq struct {
	Seq              uint64 `protobuf:"varint,1,opt,name=seq" json:"seq"`
	ContentType      string `protobuf:"bytes,2,opt,name=contentType" json:"contentType"`
	ContentLength    int64  `protobuf:"varint,3,opt,name=contentLength" json:"contentLength"`
	ChunkCount       int32  `protobuf:"varint,4,opt,name=chunkCount" json:"chunkCount"`
	ModTime          int64  `protobuf:"varint,5,opt,name=modTime" json:"modTime"`
	Camera           string `protobuf:"bytes,6,opt,name=camera" json:"camera"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InitUploadReq) Reset()                    { *m = InitUploadReq{} }
func (m *InitUploadReq) String() string            { return proto.CompactTextString(m) }
func (*InitUploadReq) ProtoMessage()               {}
func (*InitUploadReq) Descriptor() ([]byte, []int) { return fileDescriptorPb, []int{3} }

func (m *InitUploadReq) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *InitUploadReq) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *InitUploadReq) GetContentLength() int64 {
	if m != nil {
		return m.ContentLength
	}
	return 0
}

func (m *InitUploadReq) GetChunkCount() int32 {
	if m != nil {
		return m.ChunkCount
	}
	return 0
}

func (m *InitUploadReq) GetModTime() int64 {
	if m != nil {
		return m.ModTime
	}
	return 0
}

func (m *InitUploadReq) GetCamera() string {
	if m != nil {
		return m.Camera
	}
	return ""
}

type InitUploadRsp struct {
	Seq              uint64 `protobuf:"varint,1,opt,name=seq" json:"seq"`
	ID               uint64 `protobuf:"varint,2,opt,name=id" json:"id"`
	Code             Code   `protobuf:"varint,3,opt,name=code,enum=pb.Code" json:"code"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *InitUploadRsp) Reset()                    { *m = InitUploadRsp{} }
func (m *InitUploadRsp) String() string            { return proto.CompactTextString(m) }
func (*InitUploadRsp) ProtoMessage()               {}
func (*InitUploadRsp) Descriptor() ([]byte, []int) { return fileDescriptorPb, []int{4} }

func (m *InitUploadRsp) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *InitUploadRsp) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *InitUploadRsp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return CodeSucc
}

type UploadReq struct {
	ID               uint64 `protobuf:"varint,1,opt,name=id" json:"id"`
	Index            int32  `protobuf:"varint,2,opt,name=index" json:"index"`
	Data             []byte `protobuf:"bytes,3,opt,name=data" json:"data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UploadReq) Reset()                    { *m = UploadReq{} }
func (m *UploadReq) String() string            { return proto.CompactTextString(m) }
func (*UploadReq) ProtoMessage()               {}
func (*UploadReq) Descriptor() ([]byte, []int) { return fileDescriptorPb, []int{5} }

func (m *UploadReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UploadReq) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *UploadReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type UploadRsp struct {
	ID               uint64 `protobuf:"varint,1,opt,name=id" json:"id"`
	Index            int32  `protobuf:"varint,2,opt,name=index" json:"index"`
	Code             Code   `protobuf:"varint,3,opt,name=code,enum=pb.Code" json:"code"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UploadRsp) Reset()                    { *m = UploadRsp{} }
func (m *UploadRsp) String() string            { return proto.CompactTextString(m) }
func (*UploadRsp) ProtoMessage()               {}
func (*UploadRsp) Descriptor() ([]byte, []int) { return fileDescriptorPb, []int{6} }

func (m *UploadRsp) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UploadRsp) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *UploadRsp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return CodeSucc
}

type UploadCompleteReq struct {
	ID               uint64 `protobuf:"varint,1,opt,name=id" json:"id"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UploadCompleteReq) Reset()                    { *m = UploadCompleteReq{} }
func (m *UploadCompleteReq) String() string            { return proto.CompactTextString(m) }
func (*UploadCompleteReq) ProtoMessage()               {}
func (*UploadCompleteReq) Descriptor() ([]byte, []int) { return fileDescriptorPb, []int{7} }

func (m *UploadCompleteReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type UploadCompleteRsp struct {
	ID               uint64 `protobuf:"varint,1,opt,name=id" json:"id"`
	Code             Code   `protobuf:"varint,2,opt,name=code,enum=pb.Code" json:"code"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UploadCompleteRsp) Reset()                    { *m = UploadCompleteRsp{} }
func (m *UploadCompleteRsp) String() string            { return proto.CompactTextString(m) }
func (*UploadCompleteRsp) ProtoMessage()               {}
func (*UploadCompleteRsp) Descriptor() ([]byte, []int) { return fileDescriptorPb, []int{8} }

func (m *UploadCompleteRsp) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UploadCompleteRsp) GetCode() Code {
	if m != nil {
		return m.Code
	}
	return CodeSucc
}

type UploadContinue struct {
	ID               uint64 `protobuf:"varint,1,opt,name=id" json:"id"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *UploadContinue) Reset()                    { *m = UploadContinue{} }
func (m *UploadContinue) String() string            { return proto.CompactTextString(m) }
func (*UploadContinue) ProtoMessage()               {}
func (*UploadContinue) Descriptor() ([]byte, []int) { return fileDescriptorPb, []int{9} }

func (m *UploadContinue) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func init() {
	proto.RegisterType((*Camera)(nil), "pb.Camera")
	proto.RegisterType((*Handshake)(nil), "pb.Handshake")
	proto.RegisterType((*HandshakeRsp)(nil), "pb.HandshakeRsp")
	proto.RegisterType((*InitUploadReq)(nil), "pb.InitUploadReq")
	proto.RegisterType((*InitUploadRsp)(nil), "pb.InitUploadRsp")
	proto.RegisterType((*UploadReq)(nil), "pb.UploadReq")
	proto.RegisterType((*UploadRsp)(nil), "pb.UploadRsp")
	proto.RegisterType((*UploadCompleteReq)(nil), "pb.UploadCompleteReq")
	proto.RegisterType((*UploadCompleteRsp)(nil), "pb.UploadCompleteRsp")
	proto.RegisterType((*UploadContinue)(nil), "pb.UploadContinue")
	proto.RegisterEnum("pb.Code", Code_name, Code_value)
	proto.RegisterEnum("pb.Cmd", Cmd_name, Cmd_value)
}
func (m *Camera) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Camera) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintPb(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	dAtA[i] = 0x12
	i++
	i = encodeVarintPb(dAtA, i, uint64(len(m.Username)))
	i += copy(dAtA[i:], m.Username)
	dAtA[i] = 0x1a
	i++
	i = encodeVarintPb(dAtA, i, uint64(len(m.Password)))
	i += copy(dAtA[i:], m.Password)
	dAtA[i] = 0x20
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.Position))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Handshake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Handshake) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintPb(dAtA, i, uint64(len(m.Mac)))
	i += copy(dAtA[i:], m.Mac)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HandshakeRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandshakeRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.Shop))
	dAtA[i] = 0x12
	i++
	i = encodeVarintPb(dAtA, i, uint64(len(m.Mac)))
	i += copy(dAtA[i:], m.Mac)
	if len(m.Cameras) > 0 {
		for _, msg := range m.Cameras {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InitUploadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitUploadReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.Seq))
	dAtA[i] = 0x12
	i++
	i = encodeVarintPb(dAtA, i, uint64(len(m.ContentType)))
	i += copy(dAtA[i:], m.ContentType)
	dAtA[i] = 0x18
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.ContentLength))
	dAtA[i] = 0x20
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.ChunkCount))
	dAtA[i] = 0x28
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.ModTime))
	dAtA[i] = 0x32
	i++
	i = encodeVarintPb(dAtA, i, uint64(len(m.Camera)))
	i += copy(dAtA[i:], m.Camera)
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InitUploadRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitUploadRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.Seq))
	dAtA[i] = 0x10
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x18
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.Code))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.Index))
	if m.Data != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.Index))
	dAtA[i] = 0x18
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.Code))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadCompleteReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadCompleteReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.ID))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadCompleteRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadCompleteRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.ID))
	dAtA[i] = 0x10
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.Code))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UploadContinue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadContinue) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintPb(dAtA, i, uint64(m.ID))
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintPb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Camera) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	n += 1 + l + sovPb(uint64(l))
	l = len(m.Username)
	n += 1 + l + sovPb(uint64(l))
	l = len(m.Password)
	n += 1 + l + sovPb(uint64(l))
	n += 1 + sovPb(uint64(m.Position))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Handshake) Size() (n int) {
	var l int
	_ = l
	l = len(m.Mac)
	n += 1 + l + sovPb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HandshakeRsp) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPb(uint64(m.Shop))
	l = len(m.Mac)
	n += 1 + l + sovPb(uint64(l))
	if len(m.Cameras) > 0 {
		for _, e := range m.Cameras {
			l = e.Size()
			n += 1 + l + sovPb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InitUploadReq) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPb(uint64(m.Seq))
	l = len(m.ContentType)
	n += 1 + l + sovPb(uint64(l))
	n += 1 + sovPb(uint64(m.ContentLength))
	n += 1 + sovPb(uint64(m.ChunkCount))
	n += 1 + sovPb(uint64(m.ModTime))
	l = len(m.Camera)
	n += 1 + l + sovPb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InitUploadRsp) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPb(uint64(m.Seq))
	n += 1 + sovPb(uint64(m.ID))
	n += 1 + sovPb(uint64(m.Code))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadReq) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPb(uint64(m.ID))
	n += 1 + sovPb(uint64(m.Index))
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovPb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadRsp) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPb(uint64(m.ID))
	n += 1 + sovPb(uint64(m.Index))
	n += 1 + sovPb(uint64(m.Code))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadCompleteReq) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPb(uint64(m.ID))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadCompleteRsp) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPb(uint64(m.ID))
	n += 1 + sovPb(uint64(m.Code))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UploadContinue) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovPb(uint64(m.ID))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPb(x uint64) (n int) {
	return sovPb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Camera) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Camera: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Camera: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			m.Position = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Position |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Handshake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Handshake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Handshake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandshakeRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandshakeRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandshakeRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shop", wireType)
			}
			m.Shop = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shop |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cameras", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cameras = append(m.Cameras, &Camera{})
			if err := m.Cameras[len(m.Cameras)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitUploadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitUploadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitUploadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentLength", wireType)
			}
			m.ContentLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContentLength |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkCount", wireType)
			}
			m.ChunkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModTime", wireType)
			}
			m.ModTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camera", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Camera = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitUploadRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitUploadRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitUploadRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (Code(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (Code(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadCompleteReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadCompleteReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadCompleteReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadCompleteRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadCompleteRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadCompleteRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= (Code(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadContinue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadContinue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadContinue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pb.proto", fileDescriptorPb) }

var fileDescriptorPb = []byte{
	// 636 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x93, 0xdf, 0x4e, 0xdb, 0x30,
	0x14, 0xc6, 0x9b, 0x3f, 0x2d, 0xed, 0xa1, 0x05, 0x73, 0xe8, 0xb6, 0x08, 0x4d, 0xa5, 0xca, 0xd0,
	0x84, 0xd0, 0x04, 0x12, 0x8f, 0xd0, 0x6c, 0x12, 0x48, 0xfb, 0xa7, 0x14, 0xb4, 0xeb, 0x10, 0x7b,
	0x6d, 0x44, 0x63, 0x87, 0x38, 0xdd, 0xe0, 0x0d, 0x78, 0x84, 0x3d, 0x12, 0xbb, 0xe3, 0x09, 0xd8,
	0xd6, 0xbd, 0xc8, 0x64, 0xa7, 0xc9, 0x52, 0xd8, 0x60, 0xda, 0x55, 0xe3, 0xdf, 0xf9, 0xfc, 0xf9,
	0x7c, 0xc7, 0x2e, 0x34, 0x93, 0x93, 0xdd, 0x24, 0x15, 0x99, 0x40, 0x33, 0x39, 0xd9, 0xe8, 0x8e,
	0xc4, 0x48, 0xe8, 0xe5, 0x9e, 0xfa, 0xca, 0x2b, 0xee, 0xa5, 0x01, 0x0d, 0x2f, 0x88, 0x59, 0x1a,
	0xa0, 0x03, 0xf6, 0xdb, 0x20, 0x66, 0x8e, 0xd1, 0x37, 0xb6, 0x5b, 0x03, 0xfb, 0xea, 0x66, 0xb3,
	0xe6, 0x6b, 0x82, 0x7d, 0x68, 0x1e, 0x4b, 0x96, 0x72, 0x55, 0x35, 0x2b, 0xd5, 0x92, 0x2a, 0xc5,
	0xfb, 0x40, 0xca, 0xcf, 0x22, 0xa5, 0x8e, 0x55, 0x55, 0x14, 0x54, 0x2b, 0x84, 0x8c, 0xb2, 0x48,
	0x70, 0xc7, 0xee, 0x1b, 0xdb, 0x9d, 0x52, 0x31, 0xa7, 0xee, 0x33, 0x68, 0x1d, 0x04, 0x9c, 0xca,
	0x71, 0x70, 0xca, 0xf0, 0x31, 0x58, 0x71, 0x10, 0x2e, 0xf4, 0xa2, 0x80, 0xfb, 0x11, 0xda, 0xa5,
	0xc8, 0x97, 0x89, 0x6a, 0x5a, 0x8e, 0x45, 0xa2, 0x85, 0x76, 0xd1, 0xb4, 0x22, 0x85, 0x83, 0x79,
	0xcb, 0x01, 0xb7, 0x60, 0x29, 0xd4, 0x81, 0xa5, 0x63, 0xf5, 0xad, 0xed, 0xe5, 0x7d, 0xd8, 0x4d,
	0x4e, 0x76, 0xf3, 0x19, 0xf8, 0x45, 0xc9, 0xfd, 0x66, 0x40, 0xe7, 0x90, 0x47, 0xd9, 0x71, 0x32,
	0x11, 0x01, 0xf5, 0xd9, 0x99, 0xf2, 0x93, 0xec, 0x6c, 0xe1, 0x20, 0x05, 0xf0, 0x39, 0x2c, 0x87,
	0x82, 0x67, 0x8c, 0x67, 0x47, 0x17, 0xc9, 0xe2, 0x7c, 0xaa, 0x05, 0xdc, 0x81, 0xce, 0x7c, 0xf9,
	0x9a, 0xf1, 0x51, 0x36, 0xd6, 0x73, 0xb2, 0xe6, 0xca, 0xc5, 0x12, 0x6e, 0x01, 0x84, 0xe3, 0x29,
	0x3f, 0xf5, 0xc4, 0x94, 0x67, 0x7a, 0x5c, 0xf5, 0xb9, 0xb0, 0xc2, 0xb1, 0x07, 0x4b, 0xb1, 0xa0,
	0x47, 0x51, 0xcc, 0x9c, 0x7a, 0xc5, 0xab, 0x80, 0xf8, 0x14, 0x1a, 0x79, 0x1c, 0xa7, 0x51, 0x69,
	0x6a, 0xce, 0xdc, 0xd1, 0x42, 0x40, 0x99, 0xfc, 0x35, 0xe0, 0x06, 0x98, 0x11, 0xd5, 0xb9, 0xec,
	0x01, 0x28, 0x3c, 0xbb, 0xd9, 0x34, 0x0f, 0x5f, 0xfa, 0x66, 0x44, 0xd1, 0x05, 0x3b, 0x14, 0x94,
	0xe9, 0x2c, 0x2b, 0xfb, 0x4d, 0x3d, 0x49, 0x41, 0x59, 0x71, 0x11, 0xaa, 0xe6, 0x7e, 0x80, 0xd6,
	0xef, 0x29, 0xe6, 0x66, 0xc6, 0x1f, 0xcd, 0x36, 0xa0, 0x1e, 0x71, 0xca, 0xce, 0xf5, 0x59, 0x45,
	0xe0, 0x1c, 0x21, 0x82, 0x4d, 0x83, 0x2c, 0xd0, 0x07, 0xb5, 0x7d, 0xfd, 0xed, 0x8e, 0x4a, 0x63,
	0x99, 0xfc, 0xb7, 0xf1, 0xbf, 0x24, 0xd8, 0x83, 0xb5, 0xfc, 0x20, 0x4f, 0xc4, 0xc9, 0x84, 0x65,
	0xec, 0x81, 0x24, 0xee, 0xf0, 0xce, 0x86, 0x07, 0x3a, 0x2c, 0xba, 0x30, 0xef, 0xe9, 0xe2, 0x05,
	0xac, 0x14, 0xa6, 0x3c, 0x8b, 0xf8, 0x94, 0xdd, 0xe7, 0xb8, 0x73, 0x69, 0x80, 0xad, 0x2c, 0xb0,
	0x0d, 0x4d, 0xf5, 0x3b, 0x9c, 0x86, 0x21, 0xa9, 0x15, 0xab, 0xc1, 0x54, 0x5e, 0x10, 0x03, 0x57,
	0x61, 0x59, 0xad, 0xde, 0x44, 0x52, 0x46, 0x7c, 0x44, 0x4c, 0xec, 0x02, 0x51, 0xe0, 0x90, 0x7f,
	0x0a, 0x26, 0x11, 0xf5, 0xd4, 0x5b, 0x23, 0x16, 0x3e, 0x81, 0xf5, 0x05, 0xca, 0xc2, 0x53, 0x39,
	0x8d, 0x89, 0x8d, 0x04, 0xda, 0xaa, 0xf0, 0x6e, 0x38, 0x7c, 0x95, 0xa6, 0x22, 0x25, 0x75, 0x44,
	0x58, 0xd1, 0x8e, 0xc1, 0xb9, 0xcf, 0xb2, 0x34, 0x62, 0x92, 0x34, 0x76, 0xbe, 0x1a, 0x60, 0x79,
	0x31, 0xc5, 0x16, 0xd4, 0xbd, 0x98, 0x1e, 0x0c, 0x48, 0x4d, 0x6f, 0x8c, 0x69, 0xf9, 0x4f, 0x26,
	0x06, 0xae, 0xc3, 0x6a, 0x95, 0xf8, 0x32, 0x21, 0x26, 0xae, 0x41, 0xc7, 0x8b, 0x69, 0x9e, 0x5a,
	0x3d, 0x56, 0x62, 0xe9, 0x0e, 0xab, 0x48, 0x09, 0x6d, 0xec, 0x40, 0xab, 0xa4, 0xa4, 0x3e, 0xb7,
	0x2f, 0x1f, 0x07, 0x69, 0xe0, 0x23, 0x58, 0x2b, 0x49, 0x71, 0x29, 0x64, 0x09, 0x1d, 0xe8, 0xde,
	0xc1, 0x6a, 0x43, 0xf3, 0xd6, 0x86, 0x7c, 0xe0, 0xa4, 0x35, 0xe8, 0x5e, 0xff, 0xe8, 0xd5, 0xae,
	0x66, 0x3d, 0xe3, 0x7a, 0xd6, 0x33, 0xbe, 0xcf, 0x7a, 0xc6, 0x97, 0x9f, 0xbd, 0xda, 0xaf, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x69, 0x16, 0xd3, 0x0a, 0x6a, 0x05, 0x00, 0x00,
}
